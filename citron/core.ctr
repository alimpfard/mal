# File core.ctr
import Library/Data/Map.
var Core is Object cnew: {
    var namespace is Map new.
     on: 'namespace' do: {
        ^const namespace.
      }.
     on: 'coerce:' do: {:value
        value ifTrue: {
            ^MALObject true.
          } 
            ifFalse: {
            ^MALObject false.
          }.
      }.
     on: 'nilable:else:' do: {:args:block
        args head ty = \nil ifTrue: {
            ^MALObject nil.
          } 
            ifFalse: block.
      }.
     on: 'printedArgs:readable:sep:' 
        do: {:args:readable:sep
        var items is args fmap: ((((\:arg const Printer prStr: arg readably: const readable)))).
        ^items join: sep.
      }.
  }.
Core namespace put: (
    MALFunction new: {:args
        ^MALNumber new: (args at: 0, val) + (args at: 1, val).
      }) 
    at: \+.
Core namespace put: (
    MALFunction new: {:args
        ^MALNumber new: (args at: 0, val) - (args at: 1, val).
      }) 
    at: \-.
Core namespace put: (
    MALFunction new: {:args
        ^MALNumber new: (args at: 0, val) * (args at: 1, val).
      }) 
    at: \*.
Core namespace put: (
    MALFunction new: {:args
        ^MALNumber new: (args at: 0, val) / (args at: 1, val).
      }) 
    at: \/.
Core namespace put: (
    MALFunction new: {:args
        ^MALString new: (Core printedArgs: args readable: True sep: ' ').
      }) 
    at: \pr-str.
Core namespace put: (
    MALFunction new: {:args
        ^MALString new: (Core printedArgs: args readable: False sep: '').
      }) 
    at: \str.
Core namespace put: (
    MALFunction new: {:args
        Pen writeln: (Core printedArgs: args readable: True sep: ' ').
        ^MALObject nil.
      }) 
    at: \prn.
Core namespace put: (
    MALFunction new: {:args
        Pen writeln: (Core printedArgs: args readable: False sep: ' ').
        ^MALObject nil.
      }) 
    at: \println.
Core namespace put: (
    MALFunction new: {:args
        ^MALList new: args.
      }) 
    at: \list.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \list.
      }) 
    at: \list?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head val empty?.
      }) 
    at: \empty?.
Core namespace put: (
    MALFunction new: {:args
        args head ty = \nil ifTrue: {
            ^MALNumber new: 0.
          }.
        ^MALNumber new: args head val count.
      }) 
    at: \count.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (args at: 0) = (args at: 1).
      }) 
    at: \=.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (args at: 0, val) < (args at: 1, val).
      }) 
    at: \<.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (args at: 0, val) > (args at: 1, val).
      }) 
    at: \>.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: ((args at: 0, val) <=: (args at: 1, val)).
      }) 
    at: \<=.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: ((args at: 0, val) >= (args at: 1, val)).
      }) 
    at: \>=.
Core namespace put: (
    MALFunction new: {:args
        ^Reader readStr: args head val.
      }) 
    at: \read-string.
Core namespace put: (
    MALFunction new: {:args
        ^MALString new: (File new: args head val) read.
      }) 
    at: \slurp.
Core namespace put: (
    MALFunction new: {:args
        thisBlock error: (MALCustomError new: args head).
      }) 
    at: \throw.
Core namespace put: (
    MALFunction new: {:args
        var result is LineNoise new noise: args head val.
        result isNil ifTrue: {
            ^MALObject nil.
          }.
        ^MALString new: result.
      }) 
    at: \readline.
Core namespace put: (
    MALFunction new: {:args
        ^MALNumber new: Clock new time.
      }) 
    at: \time-ms.
Core namespace put: (
    MALFunction new: {:args
        ^AST parse: '{\n' + args head val + '\n}',
         at: 0,
         at: 1,
         at: 0,
         evaluate
         toMALValue.
      }) 
    at: \citron-eval.
Core namespace put: (
    MALFunction new: {:args
        ^MALAtom new: args head.
      }) 
    at: \atom.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \atom.
      }) 
    at: \atom?.
Core namespace put: (
    MALFunction new: {:args
        ^args head val.
      }) 
    at: \deref.
Core namespace put: (
    MALFunction new: {:args
        args head val: args @ 1.
        ^args @ 1.
      }) 
    at: \reset!.
Core namespace put: (
    MALFunction new: {:args
        var a is args head.
        var f is args at: 1.
        {
          thisBlock error: (MALNotAFunction new: f ty).
        } unless: ([\func, \fn ] contains: f ty).
        f is f fn.
        var x is a val.
        var xs is args viewFrom: 2.
        var result is f applyTo: [x] + xs.
        a val: result.
        ^result.
      }) 
    at: \swap!.
Core namespace put: (
    MALFunction new: {:args
        ^MALList new: [args head] + (args at: 1, val).
      }) 
    at: \cons.
Core namespace put: (
    MALFunction new: {:args
        ^MALList new: (
            args fmap: \:x x val,
             foldl: (((\:acc:x acc + x accumulator: [])))).
      }) 
    at: \concat.
Core namespace put: (
    MALFunction new: {:args
        var items is args head val.
        var index is args at: 1, val.
        index >=: items count,
         ifTrue: {
            thisBlock error: MALOutOfBounds new.
          }.
        ^items @ index.
      }) 
    at: \nth.
Core namespace put: (
    MALFunction new: {:args
        ^Core nilable: args else: {
            var items is args head val.
            items count = 0 ifTrue: {
                ^MALObject nil.
              }.
            ^items @ 0.
          }.
      }) 
    at: \first.
Core namespace put: (
    MALFunction new: {:args
        var items is args head val.
        var rest is Nil.
        (args head ty = \nil) or: {
            ^items empty?.
          },
         ifTrue: {
            rest is Array new.
          } 
            ifFalse: {
            rest is items tail.
          }.
        ^MALList new: rest.
      }) 
    at: \rest.
Core namespace put: (
    MALFunction new: {:args
        var kind is args head ty.
        var result is args head val.
        var items is args tail.
        kind = \list ifTrue: {
            ^MALList new: items reverse + [result].
          } 
            ifFalse: {
            ^MALList new: [result] + items.
          }.
      }) 
    at: \conj.
Core namespace put: (
    MALFunction new: {:args
        var kind is args head ty.
        var storage is args head val.
        ^Core nilable: args else: {
            storage empty? ifTrue: {
                ^MALObject nil.
              } 
                ifFalse: {
                kind = \string ifTrue: {
                    var result is storage characters fmap: ((((\:x const MALString new: x)))).
                    ^MALList new: result.
                  } 
                    ifFalse: {
                    ^MALList new: storage.
                  }.
              }.
          }.
      }) 
    at: \seq.
Core namespace put: (
    MALFunction new: {:args
        var f is args head.
        {
          thisBlock error: (MALNotAFunction new: f ty).
        } unless: ([\func, \fn ] contains: f ty).
        f is f fn.
        var rest is Nil.
        args count < 3 ifTrue: {
            rest is [].
          } 
            ifFalse: {
            rest is args viewFrom: 1 length: args count - 2.
          }.
        rest is rest + args last val.
        ^f applyTo: rest.
      }) 
    at: \apply.
Core namespace put: (
    MALFunction new: {:args
        var f is args head.
        {
          thisBlock error: (MALNotAFunction new: f ty).
        } unless: ([\func, \fn ] contains: f ty).
        f is f fn.
        var items is args at: 1, val.
        var result is items fmap: ((((\:x const f applyTo: [x])))).
        ^MALList new: result.
      }) 
    at: \map.
Core namespace put: (
    MALFunction new: {:args
        var meta is args head meta.
        meta isNil ifTrue: {
            ^MALObject nil.
          } 
            ifFalse: {
            ^meta.
          }.
      }) 
    at: \meta.
Core namespace put: (
    MALFunction new: {:args
        ^args head withMeta: args @ 1.
      }) 
    at: \with-meta.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \nil.
      }) 
    at: \nil?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \true.
      }) 
    at: \true?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \false.
      }) 
    at: \false?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \number.
      }) 
    at: \number?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \symbol.
      }) 
    at: \symbol?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \keyword.
      }) 
    at: \keyword?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \string.
      }) 
    at: \string?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \vector.
      }) 
    at: \vector?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: args head ty = \map.
      }) 
    at: \map?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (args head ty = \list) | (args head ty = \vector).
      }) 
    at: \sequential?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (
            (args head ty = \fn) either: True or: {
                ^(args head ty = \func) either: {
                    ^args head isMacro not.
                } or: False.
            }).
      }) 
    at: \fn?.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (
            args head ty = \func either: {
                ^args head isMacro.
              } 
                or: False).
      }) 
    at: \macro?.
Core namespace put: (
    MALFunction new: {:args
        ^MALSymbol new: args head val toSymbol.
      }) 
    at: \symbol.
Core namespace put: (
    MALFunction new: {:args
        ^MALKeyword new: args head val toSymbol.
      }) 
    at: \keyword.
Core namespace put: (
    MALFunction new: {:args
        ^MALVector new: args.
      }) 
    at: \vector.
Core namespace put: (
    MALFunction new: {:args
        ^MALMap new: args toMap.
      }) 
    at: \hash-map.
Core namespace put: (
    MALFunction new: {:args
        var result is args head val copy.
        var keyvals is args tail.
        0 to: keyvals count step: 2 do: {:i
            result put: (keyvals at: i + 1) at: (keyvals at: i).
          }.
        ^MALMap new: result.
      }) 
    at: \assoc.
Core namespace put: (
    MALFunction new: {:args
        var result is args head val copy.
        var keys is args tail.
        keys each_v: {:key
            result deleteAt: key.
          }.
        ^MALMap new: result.
      }) 
    at: \dissoc.
Core namespace put: (
    MALFunction new: {:args
        ^Core nilable: args else: {
            ^args head
             val
             at: args @ 1,
             or: MALObject nil.
          }.
      }) 
    at: \get.
Core namespace put: (
    MALFunction new: {:args
        ^Core coerce: (args head val contains: args @ 1).
      }) 
    at: \contains?.
Core namespace put: (
    MALFunction new: {:args
        ^MALList new: args head val keys.
      }) 
    at: \keys.
Core namespace put: (
    MALFunction new: {:args
        ^MALList new: args head val values.
      }) 
    at: \vals.
