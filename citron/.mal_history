"abc\ndef\nghi"
"abc\\def\\ghi"
"\\n"
(pr-str)
(pr-str "")
(pr-str "abc")
(pr-str "abc  def" "ghi jkl")
(pr-str "\"")
(pr-str (list 1 2 "abc" "\"") "def")
(pr-str "abc\ndef\nghi")
(pr-str "abc\\def\\ghi")
(pr-str (list))
(str)
(str "")
(str "abc")
(str "\"")
(str 1 "abc" 3)
(str "abc  def" "ghi jkl")
(str "abc\ndef\nghi")
(str "abc\\def\\ghi")
(str (list 1 2 "abc" "\"") "def")
(str (list))
(prn)
(prn "")
(prn "abc")
(prn "abc  def" "ghi jkl")
(prn "\"")
(prn "abc\ndef\nghi")
(prn "abc\\def\\ghi")
nil
(prn (list 1 2 "abc" "\"") "def")
(println)
(println "")
(println "abc")
(println "abc  def" "ghi jkl")
(println "\"")
(println "abc\ndef\nghi")
(println "abc\\def\\ghi")
(println (list 1 2 "abc" "\"") "def")
(= :abc :abc)
(= :abc :def)
(= :abc ":abc")
(= (list :abc) (list :abc))
(if [] 7 8)
(pr-str [1 2 "abc" "\""] "def")
(pr-str [])
(str [1 2 "abc" "\""] "def")
(str [])
(count [1 2 3])
(empty? [1 2 3])
(empty? [])
(list? [4 5 6])
(= [] (list))
(= [7 8] [7 8])
(= [:abc] [:abc])
(= (list 1 2) [1 2])
(= (list 1) [])
(= [] [1])
(= 0 [])
(= [] 0)
(= [] "")
(= "" [])
( (fn* [] 4) )
( (fn* [f x] (f x)) (fn* [a] (+ 1 a)) 7)
(= [(list)] (list []))
abcABC123
hello mal world
[]{}"'* ;:()
hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
!
&
+
,
-
/
<
=
>
?
@
^
_
`
~
#
$
%
.
|
1
7
  7   
-123
+
abc
   abc   
abc5
abc-def
-
-abc
->>
(+ 1 2)
()
( )
(nil)
((3 4))
(+ 1 (+ 2 3))
  ( +   1   (+   2 3   )   )  
(* 1 2)
(** 1 2)
(* -3 6)
(()())
(1 2, 3,,,,),,
nil
true
false
"abc"
   "abc"   
"abc (with parens)"
"abc\"def"
""
"\\"
"\\\\\\\\\\\\\\\\\\"
"&"
"'"
"("
")"
"*"
"+"
","
"-"
"/"
":"
";"
"<"
"="
">"
"?"
"@"
"["
"]"
"^"
"_"
"`"
"{"
"}"
"~"
(1 2
[1 2
"abc
"
"\"
"\\\\\\\\\\\\\\\\\\\"
(1 "abc
(1 "abc"
'1
'(1 2 3)
`1
`(1 2 3)
~1
~(1 2 3)
`(1 ~a 3)
~@(1 2 3)
:kw
(:kw1 :kw2 :kw3)
[+ 1 2]
[]
[ ]
[[3 4]]
[+ 1 [+ 2 3]]
  [ +   1   [+   2 3   ]   ]  
([])
{}
{ }
{"abc" 1}
{"a" {"b" 2}}
{"a" {"b" {"c" 3}}}
{  "a"  {"b"   {  "cde"     3   }  }}
{"a1" 1 "a2" 2 "a3" 3}
{  :a  {:b   {  :cde     3   }  }}
{"1" 1}
({})
 ;; whole line comment (not an exception)
1 ; comment after expression
1; comment after expression
@a
^{"a" 1} [1 2 3]
"\n"
"#"
"$"
"%"
"."
"\\"
"|"
1;!
1;"
1;#
1;$
1;%
1;'
1;\
1;\\
1;\\\
1;`
1; &()*+,-./:;<=>?@[]^_{|}~
"!"
(+ 1 2)
(+ 5 (* 2 3))
(- (+ 5 (* 2 3)) 3)
(/ (- (+ 5 (* 2 3)) 3) 4)
(/ (- (+ 515 (* 87 311)) 302) 27)
(* -3 6)
(/ (- (+ 515 (* -87 311)) 296) 27)
(abc 1 2 3)
()
[1 2 (+ 1 2)]
{"a" (+ 7 8)}
{:a (+ 7 8)}
(+ 1 2)
(/ (- (+ 5 (* 2 3)) 3) 4)
(def! x 3)
x
(def! x 4)
x
(def! y (+ 1 7))
y
(def! mynum 111)
(def! MYNUM 222)
mynum
MYNUM
(abc 1 2 3)
(def! w 123)
(def! w (abc))
w
(let* (z 9) z)
(let* (x 9) x)
x
(let* (z (+ 2 3)) (+ 1 z))
(let* (p (+ 2 3) q (+ 2 p)) (+ p q))
(def! y (let* (z 7) z))
y
(def! a 4)
(let* (q 9) q)
(let* (q 9) a)
(let* (z 2) (let* (q 9) a))
(let* [z 9] z)
(let* [p (+ 2 3) q (+ 2 p)] (+ p q))
(let* (a 5 b 6) [3 4 a [b 7] 8])
(list)
(list? (list))
(empty? (list))
(empty? (list 1))
(list 1 2 3)
(count (list 1 2 3))
(count (list))
(count nil)
(if (> (count (list 1 2 3)) 3) 89 78)
(if (>= (count (list 1 2 3)) 3) 89 78)
(if true 7 8)
(if false 7 8)
(if false 7 false)
(if true (+ 1 7) (+ 1 8))
(if false (+ 1 7) (+ 1 8))
(if nil 7 8)
(if 0 7 8)
(if (list) 7 8)
(if (list 1 2 3) 7 8)
(= (list) nil)
(if false (+ 1 7))
(if nil 8)
(if nil 8 7)
(if true (+ 1 7))
(= 2 1)
(= 1 1)
(= 1 2)
(= 1 (+ 1 1))
(= 2 (+ 1 1))
(= nil 1)
(= nil nil)
(> 2 1)
(> 1 1)
(> 1 2)
(>= 2 1)
(>= 1 1)
(>= 1 2)
(< 2 1)
(< 1 1)
(< 1 2)
(<= 2 1)
(<= 1 1)
(<= 1 2)
(= 1 1)
(= 0 0)
(= 1 0)
(= true true)
(= false false)
(= nil nil)
(= (list) (list))
(= (list 1 2) (list 1 2))
(= (list 1) (list))
(= (list) (list 1))
(= 0 (list))
(= (list) 0)
(= (list nil) (list))
(+ 1 2)
( (fn* (a b) (+ b a)) 3 4)
( (fn* () 4) )
( (fn* (f x) (f x)) (fn* (a) (+ 1 a)) 7)
( ( (fn* (a) (fn* (b) (+ a b))) 5) 7)
(def! gen-plus5 (fn* () (fn* (b) (+ 5 b))))
(def! plus5 (gen-plus5))
(plus5 7)
(def! gen-plusX (fn* (x) (fn* (b) (+ x b))))
(def! plus7 (gen-plusX 7))
(plus7 8)
(do (prn 101))
(do (prn 102) 7)
(do (prn 101) (prn 102) (+ 1 2))
(do (def! a 6) 7 (+ a 8))
a
(def! DO (fn* (a) 7))
(DO 3)
(def! sumdown (fn* (N) (if (> N 0) (+ N (sumdown  (- N 1))) 0)))
(sumdown 1)
(sumdown 2)
(sumdown 6)
(def! fib (fn* (N) (if (= N 0) 1 (if (= N 1) 1 (+ (fib (- N 1)) (fib (- N 2)))))))
(fib 1)
(fib 2)
(fib 4)
(let* (cst (fn* (n) (if (= n 0) nil (cst (- n 1))))) (cst 1))
(let* (f (fn* (n) (if (= n 0) 0 (g (- n 1)))) g (fn* (n) (f n))) (f 2))
(if "" 7 8)
(= "" "")
(= "abc" "abc")
(= "abc" "")
(= "" "abc")
(= "abc" "def")
(= "abc" "ABC")
(= (list) "")
(= "" (list))
( (fn* (& more) (count more)) 1 2 3)
( (fn* (& more) (list? more)) 1 2 3)
( (fn* (& more) (count more)) 1)
( (fn* (& more) (count more)) )
( (fn* (& more) (list? more)) )
( (fn* (a & more) (count more)) 1 2 3)
( (fn* (a & more) (count more)) 1)
( (fn* (a & more) (list? more)) 1)
(not false)
(not nil)
(not true)
(not "a")
(not 0)
""
"abc"
"abc  def"
"\""
"abc\ndef\nghi"
"abc\\def\\ghi"
"\\n"
(pr-str)
(pr-str "")
(pr-str "abc")
(pr-str "abc  def" "ghi jkl")
(pr-str "\"")
(pr-str (list 1 2 "abc" "\"") "def")
(pr-str "abc\ndef\nghi")
(pr-str "abc\\def\\ghi")
(pr-str (list))
(str)
(str "")
(str "abc")
(str "\"")
(str 1 "abc" 3)
(str "abc  def" "ghi jkl")
(str "abc\ndef\nghi")
(str "abc\\def\\ghi")
(str (list 1 2 "abc" "\"") "def")
(str (list))
(prn)
(prn "")
(prn "abc")
(prn "abc  def" "ghi jkl")
(prn "\"")
(prn "abc\ndef\nghi")
(prn "abc\\def\\ghi")
nil
(prn (list 1 2 "abc" "\"") "def")
(println)
(println "")
(println "abc")
(println "abc  def" "ghi jkl")
(println "\"")
(println "abc\ndef\nghi")
(println "abc\\def\\ghi")
(println (list 1 2 "abc" "\"") "def")
(= :abc :abc)
(= :abc :def)
(= :abc ":abc")
(= (list :abc) (list :abc))
(if [] 7 8)
(pr-str [1 2 "abc" "\""] "def")
(pr-str [])
(str [1 2 "abc" "\""] "def")
(str [])
(count [1 2 3])
(empty? [1 2 3])
(empty? [])
(list? [4 5 6])
(= [] (list))
(= [7 8] [7 8])
(= [:abc] [:abc])
(= (list 1 2) [1 2])
(= (list 1) [])
(= [] [1])
(= 0 [])
(= [] 0)
(= [] "")
(= "" [])
( (fn* [] 4) )
( (fn* [f x] (f x)) (fn* [a] (+ 1 a)) 7)
(= [(list)] (list []))
(= [1 2 (list 3 4 [5 6])] (list 1 2 [3 4 (list 5 6)]))
(do (do 1 2))
(read-string "(1 2 (3 4) nil)")
(read-string "(+ 2 3)")
(read-string "\"\n\"")
(read-string "7 ;; comment")
(read-string ";; comment")
(eval (read-string "(+ 2 3)"))
(slurp "../tests/test.txt")
(load-file "../tests/inc.mal")
(inc1 7)
(inc2 7)
(inc3 9)
(def! inc3 (fn* (a) (+ 3 a)))
(def! a (atom 2))
(atom? a)
(atom? 1)
(deref a)
(reset! a 3)
(deref a)
(swap! a inc3)
(deref a)
(swap! a (fn* (a) a))
(swap! a (fn* (a) (* 2 a)))
(swap! a (fn* (a b) (* a b)) 10)
(swap! a + 3)
(def! inc-it (fn* (a) (+ 1 a)))
(def! atm (atom 7))
(def! f (fn* () (swap! atm inc-it)))
(f)
(load-file "../tests/computations.mal")
(sumdown 2)
(fib 2)
(def! atm (atom 9))
@atm
(def! g (fn* [] 78))
(g)
(def! g (fn* [a] (+ a 78)))
(g 3)
(list? *ARGV*)
*ARGV*
(let* (b 12) (do (eval (read-string "(def! aa 7)")) aa ))
(load-file "../tests/incB.mal")
(inc4 7)
(inc5 7)
(load-file "../tests/incC.mal")
mymap
(def! a 1)
(let* (a 2) (eval (read-string "a")))
(read-string "1;!")
(read-string "1;\"")
(read-string "1;#")
(read-string "1;$")
(read-string "1;%")
(read-string "1;'")
(read-string "1;\\")
(read-string "1;\\\\")
(read-string "1;\\\\\\")
(read-string "1;`")
(read-string "1; &()*+,-./:;<=>?@[]^_{|}~")
(cons 1 (list))
(cons 1 (list 2))
(cons 1 (list 2 3))
(cons (list 1) (list 2 3))
(def! a (list 2 3))
(cons 1 a)
a
(concat)
(concat (list 1 2))
(concat (list 1 2) (list 3 4))
(concat (list 1 2) (list 3 4) (list 5 6))
(concat (concat))
(concat (list) (list))
(def! a (list 1 2))
(def! b (list 3 4))
(concat a b (list 5 6))
a
b
(quote 7)
(quote (1 2 3))
(quote (1 2 (3 4)))
(quasiquote 7)
(quasiquote (1 2 3))
(quasiquote (1 2 (3 4)))
(quasiquote (nil))
(quasiquote (unquote 7))
(def! a 8)
(quasiquote a)
(quasiquote (unquote a))
(quasiquote (1 a 3))
(quasiquote (1 (unquote a) 3))
(def! b (quote (1 "b" "d")))
(quasiquote (1 b 3))
(quasiquote (1 (unquote b) 3))
(quasiquote ((unquote 1) (unquote 2)))
(def! c (quote (1 "b" "d")))
(quasiquote (1 c 3))
(quasiquote (1 (splice-unquote c) 3))
(= (quote abc) (quote abc))
(= (quote abc) (quote abcd))
(= (quote abc) "abc")
(= "abc" (quote abc))
(= "abc" (str (quote abc)))
(= (quote abc) nil)
(= nil (quote abc))
'7
'(1 2 3)
'(1 2 (3 4))
(cons [1] [2 3])
(cons 1 [2 3])
(concat [1 2] (list 3 4) [5 6])
(concat [1 2])
`7
`(1 2 3)
`(1 2 (3 4))
`(nil)
`~7
(def! a 8)
`(1 ~a 3)
(def! b '(1 "b" "d"))
`(1 b 3)
`(1 ~b 3)
(def! c '(1 "b" "d"))
`(1 c 3)
`(1 ~@c 3)
(def! a 8)
`[1 a 3]
(def! c '(1 "b" "d"))
`[1 ~@c 3]
(defmacro! one (fn* () 1))
(one)
(defmacro! two (fn* () 2))
(two)
(defmacro! unless (fn* (pred a b) `(if ~pred ~b ~a)))
(unless false 7 8)
(unless true 7 8)
(defmacro! unless2 (fn* (pred a b) (list 'if (list 'not pred) a b)))
(unless2 false 7 8)
(unless2 true 7 8)
(macroexpand (unless2 2 3 4))
(defmacro! identity (fn* (x) x))
(let* (a 123) (identity a))
()
(not (= 1 1))
(not (= 1 2))
(nth (list 1) 0)
(nth (list 1 2) 1)
(nth (list 1 2 nil) 2)
(def! x "x")
(def! x (nth (list 1 2) 2))
x
(first (list))
(first (list 6))
(first (list 7 8 9))
(rest (list))
(rest (list 6))
(rest (list 7 8 9))
(cond)
(cond true 7)
(cond true 7 true 8)
(cond false 7 true 8)
(cond false 7 false 8 "else" 9)
(cond false 7 (= 2 2) 8 "else" 9)
(cond false 7 false 8 false 9)
(let* (x (cond false "no" true "yes")) x)
(nth [1] 0)
(nth [1 2] 1)
(nth [1 2 nil] 2)
(def! x "x")
(def! x (nth [1 2] 2))
x
(first [])
(first nil)
(first [10])
(first [10 11 12])
(rest [])
(rest nil)
(rest [10])
(rest [10 11 12])
(rest (cons 10 [11 12]))
(let* [x (cond false "no" true "yes")] x)
(def! x 2)
(defmacro! a (fn* [] x))
(a)
(let* (x 3) (a))
(throw "err1")
(try* 123 (catch* e 456))
(try* abc (catch* exc (prn "exc is:" exc)))
(try* (abc 1 2) (catch* exc (prn "exc is:" exc)))
(try* (nth () 1) (catch* exc (prn "exc is:" exc)))
(try* (throw "my exception") (catch* exc (do (prn "exc:" exc) 7)))
(try* (map throw (list "my err")) (catch* exc exc))
(symbol? 'abc)
(symbol? "abc")
(nil? nil)
(nil? true)
(true? true)
(true? false)
(true? true?)
(false? false)
(false? true)
(apply + (list 2 3))
(apply + 4 (list 5))
(apply prn (list 1 2 "3" (list)))
(apply prn 1 2 (list "3" (list)))
(apply list (list))
(apply symbol? (list (quote two)))
(apply (fn* (a b) (+ a b)) (list 2 3))
(apply (fn* (a b) (+ a b)) 4 (list 5))
(def! nums (list 1 2 3))
(def! double (fn* (a) (* 2 a)))
(double 3)
(map double nums) 
(map (fn* (x) (symbol? x)) (list 1 (quote two) "three"))
(throw {:msg "err2"})
(symbol? :abc)
(symbol? 'abc)
(symbol? "abc")
(symbol? (symbol "abc"))
(keyword? :abc)
(keyword? 'abc)
(keyword? "abc")
(keyword? "")
(keyword? (keyword "abc"))
(symbol "abc")
(keyword "abc")
(sequential? (list 1 2 3))
(sequential? [15])
(sequential? sequential?)
(sequential? nil)
(sequential? "abc")
(apply + 4 [5])
(apply prn 1 2 ["3" 4])
(apply list [])
(apply (fn* (a b) (+ a b)) [2 3])
(apply (fn* (a b) (+ a b)) 4 [5])
(map (fn* (a) (* 2 a)) [1 2 3])
(map (fn* [& args] (list? args)) [1 2])
(vector? [10 11])
(vector? '(12 13))
(vector 3 4 5)
(map? {})
(map? '())
(map? [])
(map? 'abc)
(map? :abc)
(hash-map "a" 1)
{"a" 1}
(assoc {} "a" 1)
(get (assoc (assoc {"a" 1 } "b" 2) "c" 3) "a")
(def! hm1 (hash-map))
(map? hm1)
(map? 1)
(map? "abc")
(get nil "a")
(get hm1 "a")
(contains? hm1 "a")
(def! hm2 (assoc hm1 "a" 1))
(get hm1 "a")
(contains? hm1 "a")
(get hm2 "a")
(contains? hm2 "a")
(keys hm1)
(keys hm2)
(keys {"1" 1})
(vals hm1)
(vals hm2)
(count (keys (assoc hm2 "b" 2 "c" 3)))
(get {:abc 123} :abc)
(contains? {:abc 123} :abc)
(contains? {:abcd 123} :abc)
(assoc {} :bcd 234)
(keyword? (nth (keys {:abc 123 :def 456}) 0))
(keyword? (nth (vals {"a" :abc "b" :def}) 0))
(def! hm4 (assoc {:a 1 :b 2} :a 3 :c 1))
(get hm4 :a)
(get hm4 :b)
(get hm4 :c)
(contains? {:abc nil} :abc)
(assoc {} :bcd nil)
(str "A" {:abc "val"} "Z")
(str true "." false "." nil "." :keyw "." 'symb)
(pr-str "A" {:abc "val"} "Z")
(pr-str true "." false "." nil "." :keyw "." 'symb)
(def! s (str {:abc "val1" :def "val2"}))
(cond (= s "{:abc val1 :def val2}") true (= s "{:def val2 :abc val1}") true)
(def! p (pr-str {:abc "val1" :def "val2"}))
(cond (= p "{:abc \"val1\" :def \"val2\"}") true (= p "{:def \"val2\" :abc \"val1\"}") true)
(apply (fn* (& more) (list? more)) [1 2 3])
(apply (fn* (& more) (list? more)) [])
(apply (fn* (a & more) (list? more)) [1])
(try* xyz)
(try* (throw (list 1 2 3)) (catch* exc (do (prn "err:" exc) 7)))
(def! hm3 (assoc hm2 "b" 2))
(count (keys hm3))
(count (vals hm3))
(dissoc hm3 "a")
(dissoc hm3 "a" "b")
(dissoc hm3 "a" "b" "c")
(count (keys hm3))
(dissoc {:cde 345 :fgh 456} :cde)
(dissoc {:cde nil :fgh 456} :cde)
(= {} {})
(= {:a 11 :b 22} (hash-map :b 22 :a 11))
(= {:a 11 :b [22 33]} (hash-map :b [22 33] :a 11))
(= {:a 11 :b {:c 33}} (hash-map :b {:c 33} :a 11))
(= {:a 11 :b 22} (hash-map :b 23 :a 11))
(= {:a 11 :b 22} (hash-map :a 11))
(= {:a [11 22]} {:a (list 11 22)})
(= {:a 11 :b 22} (list :a 11 :b 22))
(= {} [])
(= [] {})
(keyword :abc)
(keyword? (first (keys {":abc" 123 ":def" 456})))
(readline "mal-user> ")
(= "something bogus" *host-language*)
(def! e (atom {"+" +}))
(swap! e assoc "-" -)
( (get @e "+") 7 8)
( (get @e "-") 11 8)
(swap! e assoc "foo" (list))
(get @e "foo")
(swap! e assoc "bar" '(1 2 3))
(get @e "bar")
(do (list time-ms string? number? seq conj meta with-meta fn?) nil)
(meta (fn* (a) a))
(meta (with-meta (fn* (a) a) {"b" 1}))
(meta (with-meta (fn* (a) a) "abc"))
(def! l-wm (with-meta (fn* (a) a) {"b" 2}))
(meta l-wm)
(meta (with-meta l-wm {"new_meta" 123}))
(meta l-wm)
(def! f-wm (with-meta (fn* [a] (+ 1 a)) {"abc" 1}))
(meta f-wm)
(meta (with-meta f-wm {"new_meta" 123}))
(meta f-wm)
(def! f-wm2 ^{"abc" 1} (fn* [a] (+ 1 a)))
(meta f-wm2)
(meta +)
(def! gen-plusX (fn* (x) (with-meta (fn* (b) (+ x b)) {"meta" 1})))
(def! plus7 (gen-plusX 7))
(def! plus8 (gen-plusX 8))
(plus7 8)
(meta plus7)
(meta plus8)
(meta (with-meta plus7 {"meta" 2}))
(meta plus8)
(string? "")
(string? 'abc)
(string? "abc")
(string? :abc)
(string? (keyword "abc"))
(string? 234)
(string? nil)
(number? 123)
(number? -1)
(number? nil)
(number? false)
(number? "123")
(def! add1 (fn* (x) (+ x 1)))
(fn? +)
(fn? add1)
(fn? cond)
(fn? "+")
(fn? :+)
(fn? ^{"ismacro" true} (fn* () 0))
(macro? cond)
(macro? +)
(macro? add1)
(macro? "+")
(macro? :+)
(macro? {})
(conj (list) 1)
(conj (list 1) 2)
(conj (list 2 3) 4)
(conj (list 2 3) 4 5 6)
(conj (list 1) (list 2 3))
(conj [] 1)
(conj [1] 2)
(conj [2 3] 4)
(conj [2 3] 4 5 6)
(conj [1] [2 3])
(seq "abc")
(apply str (seq "this is a test"))
(seq '(2 3 4))
(seq [2 3 4])
(seq "")
(seq '())
(seq [])
(seq nil)
(meta [1 2 3])
(with-meta [1 2 3] {"a" 1})
(meta (with-meta [1 2 3] {"a" 1}))
(vector? (with-meta [1 2 3] {"a" 1}))
(meta (with-meta [1 2 3] "abc"))
(with-meta [] "abc")
(meta (with-meta (list 1 2 3) {"a" 1}))
(list? (with-meta (list 1 2 3) {"a" 1}))
(with-meta (list) {"a" 1})
(empty? (with-meta (list) {"a" 1}))
(meta (with-meta {"abc" 123} {"a" 1}))
(map? (with-meta {"abc" 123} {"a" 1}))
(with-meta {} {"a" 1})
(def! l-wm (with-meta [4 5 6] {"b" 2}))
(meta l-wm)
(meta (with-meta l-wm {"new_meta" 123}))
(meta l-wm)
(meta +)
(def! f-wm3 ^{"def" 2} +)
(meta f-wm3)
(meta +)
(load-file "../tests/computations.mal")
(def! start-time (time-ms))
(= start-time 0)
(sumdown 10) ; Waste some time
(> (time-ms) start-time)
(def! f (fn* [x] (number? x)))
(defmacro! m f)
(f (+ 1 1))
(m (+ 1 1))
(time-ms)
(- (time-ms) (time-ms))
(readline "mal-user> ")
(= "something bogus" *host-language*)
(def! e (atom {"+" +}))
(swap! e assoc "-" -)
( (get @e "+") 7 8)
( (get @e "-") 11 8)
(swap! e assoc "foo" (list))
(get @e "foo")
(swap! e assoc "bar" '(1 2 3))
(get @e "bar")
(do (list time-ms string? number? seq conj meta with-meta fn?) nil)
(meta (fn* (a) a))
(meta (with-meta (fn* (a) a) {"b" 1}))
(meta (with-meta (fn* (a) a) "abc"))
(def! l-wm (with-meta (fn* (a) a) {"b" 2}))
(meta l-wm)
(meta (with-meta l-wm {"new_meta" 123}))
(meta l-wm)
(def! f-wm (with-meta (fn* [a] (+ 1 a)) {"abc" 1}))
(meta f-wm)
(meta (with-meta f-wm {"new_meta" 123}))
(meta f-wm)
(def! f-wm2 ^{"abc" 1} (fn* [a] (+ 1 a)))
(meta f-wm2)
(meta +)
(def! gen-plusX (fn* (x) (with-meta (fn* (b) (+ x b)) {"meta" 1})))
(def! plus7 (gen-plusX 7))
(def! plus8 (gen-plusX 8))
(plus7 8)
(meta plus7)
(meta plus8)
(meta (with-meta plus7 {"meta" 2}))
(meta plus8)
(string? "")
(string? 'abc)
(string? "abc")
(string? :abc)
(string? (keyword "abc"))
(string? 234)
(string? nil)
(number? 123)
(number? -1)
(number? nil)
(number? false)
(number? "123")
(def! add1 (fn* (x) (+ x 1)))
(fn? +)
(fn? add1)
(fn? cond)
(fn? "+")
(fn? :+)
(fn? ^{"ismacro" true} (fn* () 0))
(macro? cond)
(macro? +)
(macro? add1)
(macro? "+")
(macro? :+)
(macro? {})
(conj (list) 1)
(conj (list 1) 2)
(conj (list 2 3) 4)
(conj (list 2 3) 4 5 6)
(conj (list 1) (list 2 3))
(conj [] 1)
(conj [1] 2)
(conj [2 3] 4)
(conj [2 3] 4 5 6)
(conj [1] [2 3])
(seq "abc")
(apply str (seq "this is a test"))
(seq '(2 3 4))
(seq [2 3 4])
(seq "")
(seq '())
(seq [])
(seq nil)
(meta [1 2 3])
(with-meta [1 2 3] {"a" 1})
(meta (with-meta [1 2 3] {"a" 1}))
(vector? (with-meta [1 2 3] {"a" 1}))
(meta (with-meta [1 2 3] "abc"))
(with-meta [] "abc")
(meta (with-meta (list 1 2 3) {"a" 1}))
(list? (with-meta (list 1 2 3) {"a" 1}))
(with-meta (list) {"a" 1})
(empty? (with-meta (list) {"a" 1}))
(meta (with-meta {"abc" 123} {"a" 1}))
(map? (with-meta {"abc" 123} {"a" 1}))
(with-meta {} {"a" 1})
(def! l-wm (with-meta [4 5 6] {"b" 2}))
(meta l-wm)
(meta (with-meta l-wm {"new_meta" 123}))
(meta l-wm)
(meta +)
(def! f-wm3 ^{"def" 2} +)
(meta f-wm3)
(meta +)
(load-file "../tests/computations.mal")
(def! start-time (time-ms))
(= start-time 0)
(sumdown 10) ; Waste some time
(> (time-ms) start-time)
(def! f (fn* [x] (number? x)))
(defmacro! m f)
(f (+ 1 1))
(m (+ 1 1))
(+ 1 2)
abcABC123
hello mal world
[]{}"'* ;:()
hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
!
&
+
,
-
/
<
=
>
?
@
^
_
`
~
#
$
%
.
|
abcABC123
hello mal world
[]{}"'* ;:()
hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
!
&
+
,
-
/
<
=
>
?
@
^
_
`
~
#
$
%
.
|
abcABC123
hello mal world
[]{}"'* ;:()
hello world abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789 (;:() []{}"'* ;:() []{}"'* ;:() []{}"'*)
!
&
+
,
-
/
<
=
>
?
@
^
_
`
~
#
$
%
.
|
